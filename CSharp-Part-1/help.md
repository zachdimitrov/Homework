#### побитови операции
##### кратко описание на операторите
 &          | \            |     ^       |   описание
 -----------| ------------ | ----------- | ----------------------------
 0 & 1 = 0  |  0 \| 1 = 1  |  0 ^ 1 = 1  | логическо И връща 1 само ако И двете са 1 
 1 & 1 = 1  |  1 \| 1 = 1  |  1 ^ 1 = 0  | логическо ИЛИ връща 1 ако първото ИЛИ второто е 1 
 0 & 0 = 0  |  0 \| 0 = 0  |  0 ^ 0 = 0  | логическо отрицание  връща 1 само ако едното е 1 а другото 0 

##### принтиране като двоично - с добавяне на нули (до 32 в случая).
```C#
Console.WriteLine("{0}", Convert.ToString(number, 2).PadLeft(32, '0'));
```
за отрицателно число добавяме '1'
##### оператори >> и << и създаване на маски
```C#
int mask = 1 << 4; //10000
mask = mask >> 4; //10000
```
създаване на маска с n на брой битове
```C#
int mask = 1 << n; // if n = 3 mask = 00001000
mask -= 1;         // mask = 00000111
```
##### взимане на бит с позиция 'p'
```C#
int position = 4;
int number = 19;            //00010011
int mask = 1 << position;   //00010000
int result = number & mask; //00010000  бита на позиция 4 е 0
result = result >> position;//00000001  за да получим съответния бит като резултат
```
##### зануляване на бит с позиция 'p' и включване на занулен бит
```C#
int position = 4;
int number = 19;            //00010011
int mask = ~(1<<p)          //11101111 инвъртваме числото 00010000 с ~
int result = n & mask;      //00000011 изтрива се бита на позицията 0 от mask, получихме числото 3
```
за да включим отново зануления бит
```C#
int position = 4;
int number = 3;               //00000011
int bitValue = 1 << position; //00010000
result = result | bitValue;   //00010011 или числото 19
```
##### това се ползва и за смяна на местата на битове в 3 стъпки
 - ще си запазим бита на позиция P, ще си запазим бита на позиция N
 - ще занулим бита на позиция P, ще занулим бита на позиция N
 - ще shift-нем бита от позиция P на позиция N и ще го OR-нем със зануленото число,
   ще shift-нем бита от позиция N на позиция P и ще го OR-нем със зануленото число

за да разменим поредица от битове си правим маска с няколко 1-ци описана по-горе

##### за да върнем броя на включените битове в едно число (32 бита в примера)
```C#
int count = 0;                // брояч на битове
int number = 19;               // 00000000 00000000 00000000 00010011
for (p = 0; p < 32; p++)      // за всеки бит от числото
{
  int bit = number >> p & 1;  // изместваме числото надясно и & с 1
  if (bit == 1)               // ако резултата е 1 най-десния бит е бил 1
  {
    count++;                  // и когато е 1 увеличаваме брояча
  }
}
```
можем да намерим кой по ред е 1-вия бит от дясно и кой от ляво с 2 нови променливи
```C#
int leftBit = 0;
int rightBit = 0;
int count = 0;                // брояч на битове
int number = 19;               // 00000000 00000000 00000000 00010011
for (p = 0; p < 32; p++)      // за всеки бит от числото
{
  int bit = number >> p & 1;  // изместваме числото надясно и &-ваме с 1
  if (bit == 1)               // ако резултата е 1 най-десния бит е бил 1
  {
    if (count == 0)           // когато намерим бит за 1-ви път 
    {
      rightBit = p;           // той е на позиция p (броено от дясно от 0)
    }
    count++;                  // и когато е 1 увеличаваме брояча
    leftBit = p;              // последния бит otlqwo ще е на позиция p (броено от дясно от 0)
  }
}
```




